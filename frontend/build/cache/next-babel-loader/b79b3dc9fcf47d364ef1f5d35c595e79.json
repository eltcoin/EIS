{"ast":null,"code":"import _regeneratorRuntime from \"@babel/runtime-corejs2/regenerator\";\nimport _asyncToGenerator from \"@babel/runtime-corejs2/helpers/esm/asyncToGenerator\";\nimport Web3 from 'web3'; // const web3 = new Web3('http://localhost:8545' , null, { });\n// || Web3.givenProvider\n// Metamask automatically does gas estimation for us\n// Make sure to connect to local Ganache instance at http://localhost:8545\n\nvar web3 = new Web3(Web3.givenProvider, null, {}); // const { readFileSync } = require('fs')\n\nvar registry = new web3.eth.Contract(require('../../contracts/out/Registry.json'), require('../../contracts/deploy/Registry.js'));\nexport var LOAD_ENTRY_PROGRESS = 'LOAD_ENTRY_PROGRESS';\nexport var LOAD_ENTRY_COMPLETE = 'LOAD_ENTRY_COMPLETE';\nexport function loadEntry(title) {\n  // registry.lookup(key) => entryId[]\n  // entryId is stored offchain but let's store everything onchain for now\n  return (\n    /*#__PURE__*/\n    function () {\n      var _ref = _asyncToGenerator(\n      /*#__PURE__*/\n      _regeneratorRuntime.mark(function _callee(dispatch) {\n        var key, evs, results;\n        return _regeneratorRuntime.wrap(function _callee$(_context) {\n          while (1) {\n            switch (_context.prev = _context.next) {\n              case 0:\n                dispatch({\n                  type: LOAD_ENTRY_PROGRESS,\n                  title: title\n                });\n                key = web3.utils.keccak256(title); // debugger\n\n                console.log(key);\n                _context.next = 5;\n                return registry.getPastEvents('Put', {\n                  filter: {\n                    key: key\n                  },\n                  fromBlock: '0',\n                  toBlock: 'latest'\n                });\n\n              case 5:\n                evs = _context.sent;\n                results = evs.map(function (ev) {\n                  var _ev$returnValues = ev.returnValues,\n                      url = _ev$returnValues.url,\n                      creator = _ev$returnValues.creator,\n                      key = _ev$returnValues.key,\n                      time = _ev$returnValues.time;\n                  return {\n                    url: url,\n                    creator: creator,\n                    key: key,\n                    total: 0,\n                    time: time.toNumber()\n                  };\n                });\n                dispatch(loadEntryComplete(results));\n\n              case 8:\n              case \"end\":\n                return _context.stop();\n            }\n          }\n        }, _callee);\n      }));\n\n      return function (_x) {\n        return _ref.apply(this, arguments);\n      };\n    }()\n  );\n}\n\nfunction loadEntryComplete(results) {\n  return {\n    type: LOAD_ENTRY_COMPLETE,\n    results: results\n  };\n}\n\nexport var LOAD_NEWEST_ENTRIES_COMPLETE = 'LOAD_NEWEST_ENTRIES_COMPLETE';\nexport function loadNewestEntries() {\n  return (\n    /*#__PURE__*/\n    function () {\n      var _ref2 = _asyncToGenerator(\n      /*#__PURE__*/\n      _regeneratorRuntime.mark(function _callee2(dispatch) {\n        return _regeneratorRuntime.wrap(function _callee2$(_context2) {\n          while (1) {\n            switch (_context2.prev = _context2.next) {\n              case 0:\n              case \"end\":\n                return _context2.stop();\n            }\n          }\n        }, _callee2);\n      }));\n\n      return function (_x2) {\n        return _ref2.apply(this, arguments);\n      };\n    }()\n  );\n}\n\nfunction sortEntries(entries) {// sort by the EBSL weighted whatever\n  // just load a big matrix, and cache it offline for later\n  // but we have to load all trust relations\n  // make a fucckton of calls to the chain\n  // which is probably why it's best to update this matrix on chain from time to time \n  // so we can just call it and the node's already know\n}\n\nimport { trackTx } from './txs';\nexport var ADD_TO_REGISTRY_PROGRESS = 'ADD_TO_REGISTRY_PROGRESS';\nexport function addToRegistry(title, url) {\n  return (\n    /*#__PURE__*/\n    function () {\n      var _ref3 = _asyncToGenerator(\n      /*#__PURE__*/\n      _regeneratorRuntime.mark(function _callee3(dispatch) {\n        var accounts, ev;\n        return _regeneratorRuntime.wrap(function _callee3$(_context3) {\n          while (1) {\n            switch (_context3.prev = _context3.next) {\n              case 0:\n                dispatch({\n                  type: ADD_TO_REGISTRY_PROGRESS,\n                  txhash: null\n                });\n                _context3.next = 3;\n                return web3.eth.getAccounts();\n\n              case 3:\n                accounts = _context3.sent;\n                ev = registry.methods.put(title, url).send({\n                  from: accounts[0]\n                });\n                ev.on('transactionHash', function (txhash) {\n                  dispatch({\n                    type: ADD_TO_REGISTRY_PROGRESS,\n                    txhash: txhash\n                  });\n                  dispatch(trackTx(ev, txhash));\n                });\n\n              case 6:\n              case \"end\":\n                return _context3.stop();\n            }\n          }\n        }, _callee3);\n      }));\n\n      return function (_x3) {\n        return _ref3.apply(this, arguments);\n      };\n    }()\n  );\n}","map":null,"metadata":{},"sourceType":"module"}